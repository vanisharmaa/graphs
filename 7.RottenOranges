class Solution {
public:
    int minTime(vector<vector<int>>& grid, int n, int m, int** visited){
        queue<pair<pair<int, int>, int>> q;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 2){
                    q.push({{i,j}, 0});
                    visited[i][j] = 2;
                }
            }
        }
        int maxTime = 0;
        while(!q.empty()){
            pair<pair<int,int>,int> curr = q.front();
            q.pop();
            int i = curr.first.first;
            int j = curr.first.second;
            int time = curr.second;
            maxTime = max(maxTime, time);
            //vertically up
            int newi = i-1, newj = j;
            if(newi < 0 or newi >= n or newj < 0 or newj >= m){

            }
            else if(!visited[newi][newj] and grid[newi][newj] == 1){
                visited[newi][newj] = 2;
                grid[newi][newj] = 2;
                q.push({{newi, newj}, time+1});
            }
            //horizontally left
            newi = i, newj = j-1;
            if(newi < 0 or newi >= n or newj < 0 or newj >= m){

            }
            else if(!visited[newi][newj] and grid[newi][newj] == 1){
                visited[newi][newj] = 2;
                grid[newi][newj] = 2;
                q.push({{newi, newj}, time+1});
            }
            //horizontally right
            newi = i, newj = j+1;
            if(newi < 0 or newi >= n or newj < 0 or newj >= m){

            }
            else if(!visited[newi][newj] and grid[newi][newj] == 1){
                visited[newi][newj] = 2;
                grid[newi][newj] = 2;
                q.push({{newi, newj}, time+1});
            }
            //vertically down
            newi = i+1, newj = j;
            if(newi < 0 or newi >= n or newj < 0 or newj >= m){

            }
            else if(!visited[newi][newj] and grid[newi][newj] == 1){
                visited[newi][newj] = 2;
                grid[newi][newj] = 2;
                q.push({{newi, newj}, time+1});
            }
        }
        return maxTime;
    }
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int** visited = new int*[n];
        for(int i = 0; i < n ; i++){
            visited[i] = new int[m];
            for(int j = 0 ; j < m; j++){
                visited[i][j] = 0;
            }
        }
        int ans = minTime(grid, n, m, visited);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                // cout << visited[i][j] <<" ";
                if(grid[i][j] == 1){
                    return -1;
                }
            }
            cout << endl;
        }
        return ans;
    }
};
